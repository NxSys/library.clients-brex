<?php

declare(strict_types=1);

/*
 * This file has been auto generated by Jane,
 *
 * Do no edit it directly.
 */

namespace NxSys\Library\Clients\Brex\API\Payments;

class Client extends Runtime\Client\Client
{
    /**
     * This endpoint creates a new incoming transfer. You may use use any eligible bank account connection to fund (ACH Debit)
     * any active Brex cash account.
     *
     **Reminder**: You may not use the Brex API for any activity that requires a license or registration from any
     * governmental authority without Brex's prior review and approval. This includes but is not limited to any money services
     * business or money transmission activity.
     *
     * Please review the <a href="https://www.brex.com/legal/developer-portal/">Brex Access Agreement</a> and contact us if
     * you have any questions.
     *
     * @param array $headerParameters {
     *
     * @var string $Idempotency-Key
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\Transfer|\Psr\Http\Message\ResponseInterface|null
     */
    public function createIncomingTransfer(Model\CreateIncomingTransferRequest $requestBody, array $headerParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\CreateIncomingTransfer($requestBody, $headerParameters), $fetch);
    }

    /**
     * This endpoint lists all bank connections that are eligible to make ACH transfers to Brex cash account.
     *
     * @param array $queryParameters {
     *
     * @var string $cursor
     * @var int    $limit
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\PageBankConnection|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\ListLinkedAccountsBadRequestException
     * @throws Exception\ListLinkedAccountsUnauthorizedException
     * @throws Exception\ListLinkedAccountsForbiddenException
     */
    public function listLinkedAccounts(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\ListLinkedAccounts($queryParameters), $fetch);
    }

    /**
     * This endpoint lists existing transfers for an account.
     *
     * Currently, the API can only return transfers for the following payment rails:
     * - ACH
     * - DOMESTIC_WIRE
     * - CHEQUE
     * - INTERNATIONAL_WIRE
     *
     * @param array $queryParameters {
     *
     * @var string $cursor
     * @var int    $limit
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\PageTransfer|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\ListTransfersBadRequestException
     * @throws Exception\ListTransfersUnauthorizedException
     * @throws Exception\ListTransfersForbiddenException
     * @throws Exception\ListTransfersInternalServerErrorException
     */
    public function listTransfers(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\ListTransfers($queryParameters), $fetch);
    }

    /**
     * This endpoint creates a new transfer.
     *
     * Currently, the API can only create transfers for the following payment rails:
     * - ACH
     * - DOMESTIC_WIRE
     * - CHEQUE
     * - INTERNATIONAL_WIRES (For vendors already created through dashboard. Rate limited to 100/day - Please reach out to developer-support@brex.com if you need to do more)
     *
     **Transaction Descriptions**
     * For outgoing check payments, a successful transfer will return a response containing a description value with a format of `Check #<check number> to <recipient_name> - <external_memo>`.
     * For book transfers (from one Brex Cash account to another), the recipient value will have a format of `<customer_account.dba_name> - <external_memo>` and the sender will have a format of `<target customer account's dba name> - <external_memo>`.
     * For other payment rails, the format will be `<counterparty_name> - <external_memo>`, where Counterparty name is `payment_instrument.beneficiary_name` or `contact.name`
     * For vendors created from the Payments API, the `counterparty_name` will be the `company_name` [field](/openapi/payments_api/#operation/createVendor!path=company_name&t=request).
     *
     **Reminder**: You may not use the Brex API for any activity that requires a license or registration from any
     * governmental authority without Brex's prior review and approval. This includes but is not limited to any money services
     * business or money transmission activity.
     *
     * Please review the <a href="https://www.brex.com/legal/developer-portal/">Brex Access Agreement</a> and contact us if
     * you have any questions.
     *
     * @param array $headerParameters {
     *
     * @var string $Idempotency-Key
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\Transfer|\Psr\Http\Message\ResponseInterface|null
     */
    public function createTransfer(Model\CreateTransferRequest $requestBody, array $headerParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\CreateTransfer($requestBody, $headerParameters), $fetch);
    }

    /**
     * This endpoint gets a transfer by ID.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\Transfer|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetTransfersByIdBadRequestException
     * @throws Exception\GetTransfersByIdUnauthorizedException
     * @throws Exception\GetTransfersByIdForbiddenException
     * @throws Exception\GetTransfersByIdInternalServerErrorException
     */
    public function getTransfersById(string $id, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetTransfersById($id), $fetch);
    }

    /**
     * This endpoint lists all existing vendors for an account.
     * Takes an optional parameter to match by vendor name.
     *
     * @param array $queryParameters {
     *
     * @var string $cursor
     * @var int    $limit
     * @var string $name
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\PageVendorResponse|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\ListVendorsBadRequestException
     * @throws Exception\ListVendorsUnauthorizedException
     * @throws Exception\ListVendorsForbiddenException
     */
    public function listVendors(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\ListVendors($queryParameters), $fetch);
    }

    /**
     * This endpoint creates a new vendor.
     *
     * @param array $headerParameters {
     *
     * @var string $Idempotency-Key
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\VendorResponse|\Psr\Http\Message\ResponseInterface|null
     */
    public function createVendor(Model\CreateVendorRequest $requestBody, array $headerParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\CreateVendor($requestBody, $headerParameters), $fetch);
    }

    /**
     * This endpoint deletes a vendor by ID.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function deleteVendor(string $id, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\DeleteVendor($id), $fetch);
    }

    /**
     * This endpoint gets a vendor by ID.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\VendorResponse|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetVendorByIdBadRequestException
     * @throws Exception\GetVendorByIdUnauthorizedException
     * @throws Exception\GetVendorByIdForbiddenException
     * @throws Exception\GetVendorByIdInternalServerErrorException
     */
    public function getVendorById(string $id, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetVendorById($id), $fetch);
    }

    /**
     * Updates an existing vendor by ID.
     *
     * @param array $headerParameters {
     *
     * @var string $Idempotency-Key
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\VendorResponse|\Psr\Http\Message\ResponseInterface|null
     */
    public function updateVendor(string $id, Model\UpdateVendorRequest $requestBody, array $headerParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\UpdateVendor($id, $requestBody, $headerParameters), $fetch);
    }

    public static function create($httpClient = null, array $additionalPlugins = [], array $additionalNormalizers = [])
    {
        if (null === $httpClient) {
            $httpClient = \Http\Discovery\Psr18ClientDiscovery::find();
            $plugins = [];
            $uri = \Http\Discovery\Psr17FactoryDiscovery::findUriFactory()->createUri('https://platform.brexapis.com');
            $plugins[] = new \Http\Client\Common\Plugin\AddHostPlugin($uri);
            if (count($additionalPlugins) > 0) {
                $plugins = array_merge($plugins, $additionalPlugins);
            }
            $httpClient = new \Http\Client\Common\PluginClient($httpClient, $plugins);
        }
        $requestFactory = \Http\Discovery\Psr17FactoryDiscovery::findRequestFactory();
        $streamFactory = \Http\Discovery\Psr17FactoryDiscovery::findStreamFactory();
        $normalizers = [new \Symfony\Component\Serializer\Normalizer\ArrayDenormalizer(), new Normalizer\JaneObjectNormalizer()];
        if (count($additionalNormalizers) > 0) {
            $normalizers = array_merge($normalizers, $additionalNormalizers);
        }
        $serializer = new \Symfony\Component\Serializer\Serializer($normalizers, [new \Symfony\Component\Serializer\Encoder\JsonEncoder(new \Symfony\Component\Serializer\Encoder\JsonEncode(), new \Symfony\Component\Serializer\Encoder\JsonDecode(['json_decode_associative' => true]))]);

        return new static($httpClient, $requestFactory, $serializer, $streamFactory);
    }
}
